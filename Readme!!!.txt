/*******************************Copyright (c)***********************************
  *                      北京交通大学Robocon2015机器人小组
  ******************************************************************************
  * @文件	Readme!!!.txt
  * @日期	2015-2-17
  * @说明	说明文档
  ******************************************************************************
  * 北京交通大学-通信1208-赵小铭
  *
  * 说明:	IAR版本:7.20.2.7314
  *      	库文件版本:标准库 V1.3.0
  *         UCOS版本:3.04.04(已自行修改添加FPU的支持)
  * 文件缩进:	Tab Size:4
  * 自动缩进:	Body:4          
  * 详细说明见Documents中Readme.txt
  ******************************************************************************
  */
  
基本说明：
      1、此工程使用IAR7.20.2.7314版本创建，使用IAR7.20.2.7314或以上版本打开。
      2、此工程库文件版本为STM32F4XX标准库 V1.3.0。
      3、格式说明：
	     Tools -> Options -> Editor
		      Tab Size设置为4，Indent Size设置为4，勾选Insert Tab
	     Tools -> Options -> Editor右侧点击Configure
		      Body设置为4。
	  4、项目Options -> C/C++ Compiler -> Preprocessor
	     (1)Additional include directories:
		    $PROJ_DIR$\USER
		    $PROJ_DIR$\APP
		    $PROJ_DIR$\CMSIS
		    $PROJ_DIR$\FWLib\inc
		    $PROJ_DIR$\FWLib\src
		    $PROJ_DIR$\BSP\inc
		 (2)Defined Symbols:
		    STM32F40XX
		    USE_STDPERIPH_DRIVER
		    ARM_MATH_CM4
	   5、开启了FPU -> VFPv4

Workspace结构说明：
      1、BSP(Board Support Package)是板级支持包。下面为一些基本的驱动。
      2、App(应用层)下面主要为一些算法的上层实现。
      3、CM4中为系统初始化配置，不要随便动。
      4、Documents中为说明和一些ST官方的使用手册，整理在一起方便查找。
      5、DSP_Lib为针对ARM Cortex-M4内核的DSP库。引用arm_math.h使用DSP库中的函数
         比直接使用math.h速度更快，效率更高。由于文件较多，编译后占用空间大，
         默认不用的统统放在UnCompile中。具体使用方法参见ST官方给出的Examples。
         (1)Complie中为参与编译的文件。
         (2)UuCompile中为不参与编译的文件。
      5、FWLib中为标准固件库。为了加快编译速度，区分了Compile和UnCompile。
         (1)Complie中为参与编译的文件。
         (2)UuCompile中为不参与编译的文件。
      6、Startup中为STM32启动的汇编代码。
      7、Output为编译生成的文件。
      8、工程根路径下为通用文件。
      9、UCOSIII（UCOSIII系统文件）
             |---->uC-CPU（CPU相关）
             |       |--->Cfg
             |       |--->Ports
             |       |___其它
             |---->uC-LIB（CPU硬件相关）
             |       |--->Cfg
             |       |--->Ports
             |       |___其它
             |---->uCOSIII（操作系统关键部分）
                     |--->Cfg
                     |--->Ports
                     |___>Source
程序结构说明：
      1、BSP中每一个.c和.h文件对应一个外设。定义一个结构体变量。
      2、一个工程定义一个总的结构体变量，其中成员为各个外设和应用需要使用的变量。
      3、工程总的结构体变量中使用指针指向各个文件中的结构体。
	  
文件结构说明：
      CMSIS(Cortex 微控制器软件接口标准)
	        startup -> startup_stm32f40_41xxx.s ：启动汇编代码
	        core_cm4.h ：Cortex-M4全局声明和定义，静态函数定义
	        core_cm4_simd.h ：Cortex-M4单指令多数据流(simd)，优化性能为主
	        stm32f4xx.h ：顶层驱动头文件
	        system_stm32f4xx.c ：设备具体定义
	        system_stm32f4xx.h ：设备特定的声明
			arm_math.h :DSP库头文件定义
	       *core_cmFunc.h ：Cortex-M内核功能访问接口
	       *core_cmInstr.h ：Cortex-M内核访问指令
      Config
	        stm32f40x_ram.icf:RAM中调试的链接文件
	        stm32f40x_flash.icf:FLASH中调试的链接文件
      FWLib(标准外设库)
	        DSP_Lib(DSP库函数)DSP_Lib为针对ARM Cortex-M4内核的DSP库。
	        引用arm_math.h使用DSP库中的函数比直接使用math.h速度更快，效率更高。
	        具体使用方法参见ST官方给出的Examples。
      UCOSIII（UCOSIII系统文件）
           |---->uC-CPU（CPU相关）
           |       |--->Cfg
           |       |--->Ports
           |       |___其它
           |---->uC-LIB（CPU硬件相关）
           |       |--->Cfg
           |       |--->Ports
           |       |___其它
           |---->uCOSIII（操作系统关键部分）
                   |--->Cfg
                   |--->Ports
                   |___>Source
      App(系统应用函数)
      BSP(板级支持包)
      USER(用户主文件)
	        stm32f4xx_conf.h ：配置文件,需要使用某一个外设时,到此文件中取消其注释
	        stm32f4xx_it.c ：中断函数模板
	        stm32f4xx_it.h ：中断函数模板
	        includes.h ：头文件引用
	        main.c ：主函数所在
	        Sysinit.c ：系统初始化函数定义
	        Sysinit.h ：系统初始化函数声明
      Documents(文档说明)
	  
UCOSIII说明：
      UCOS版本:3.04.04(已自行修改添加FPU的支持)。
       经过不懈努力，此工程成功的开启了硬件FPU功能。
      
      关键函数说明的翻译以及UCOSIII使用的一些说明：
      1、OSTaskCreate说明：
/*
************************************************************************************************************************
*                                                    CREATE A TASK
*
* Description: 创建任务。任务可以在多任务环境开始创建，也可以在运行着的任务中创建。但是不能在中断中创建。
*
* Arguments  : p_tcb          指向任务控制块(TCB)的指针。
*
*              p_name         指向任务名称的指针。
*
*              p_task         指向任务代码的指针。
*
*              p_arg          可选参数，任务第一次运行时用来向任务传递参数。有传递参数的任务代码应该以下面的形式编写：
*
*                                 void Task (void *p_arg)
*                                 {
*                                     for (;;) {
*                                         Task code;
*                                     }
*                                 }
*
*              prio           任务优先级。每个任务必须有唯一的优先级。数字越小优先级越高。
*
*              p_stk_base     指向任务堆栈的指针。(注:Cortex-M是由上向下生长的满栈)
*
*              stk_limit      堆栈元素“溅出(watermark)”大小。(相当于堆栈使用空间的一个限制)。
*                             代表了在堆栈用满之前CPU_STK剩余的大小。
*                             比如：设置为堆栈大小的10%，表明堆栈使用最多只能达到堆栈大小的90%。
*
*              stk_size       堆栈大小。
*                             如果CPU_STK设置为CPU_INT08U，'stk_size' 代表可以使用的字节数。
*                             如果CPU_STK设置为CPU_INT16U，'stk_size' 代表可以使用的半字(16位元素)数。
*                             如果CPU_STK设置为CPU_INT32U，'stk_size' 代表可以使用的字(32位元素)数。
*
*              q_size         此任务最多可接受的消息数目。
*
*              time_quanta    round-robin时间片轮转中的时间片大小。默认为0。单位为tick数目。
*                             (注：UCOSIII支持同优先级的任务以时间片进行轮转，请自行百度相关知识）
*
*              p_ext          指向作为TCB扩展空间的用户应用存储空间。
*                             比如：这个用户存储空间可以在上下文切换时，每次任务执行时或者每次任务进入时保存浮点寄存器。
*
*              opt            任务行为选项。参考OS_OPT_TASK_xxx in OS.H。
*                             目前可选值为:
*
*                                 OS_OPT_TASK_NONE            没有选项选中。
*                                 OS_OPT_TASK_STK_CHK         使能堆栈检测。
*                                 OS_OPT_TASK_STK_CLR         堆栈创建时清空堆栈。
*                                 OS_OPT_TASK_SAVE_FP         如果开启了FPU，在上下文切换时保存浮点寄存器。
*                                                             (注:经过努力，成功的开启了FPU，可以在需要浮点运算的任务中选中此选项)
*                                 OS_OPT_TASK_NO_TLS          失能此任务的TLS (Thread Local Storage)。
*                                                             如果不选中，默认开启TSL。
*
*              p_err          错误代码。
*                             取值如下：
*
*                                 OS_ERR_NONE                    操作成功。
*                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME 非法创建任务。即在OSSafetyCriticalStart()之后创建任务。
*                                 OS_ERR_NAME                    'p_name'为空指针。
*                                 OS_ERR_PRIO_INVALID            任务优先级无效。
*                                                                优先级大于了最大优先级>= OS_CFG_PRIO_MAX-1)，或者
*                                                                在OS_CFG_ISR_POST_DEFERRED_EN置1时，使用0号保留优先级。
*                                 OS_ERR_STK_INVALID             'p_stk_base'为空。
*                                 OS_ERR_STK_SIZE_INVALID        'stk_size'为0。
*                                 OS_ERR_STK_LIMIT_INVALID       'stk_limit'大于或等于'stk_size'。
*                                 OS_ERR_TASK_CREATE_ISR         在中断中创建任务。
*                                 OS_ERR_TASK_INVALID            'p_task'为空。
*                                 OS_ERR_TCB_INVALID             'p_tcb'为空。
*
* Returns    : none
************************************************************************************************************************
*/

      2、OSInit说明：
/* 
*********************************************************************************************************** 
*                                                    初始化
* 
* 功能说明: 此函数用于uC/OS-III的内部初始化，这个函数是使用uC/OS-III时需要第一个执行的函数，切记不要搞错顺
*           序，然后才是任务创建和OS_Start(). 
* 形   参: p_err 变量指针，用于返回错误代码 
*          OS_ERR_NONE 初始化成功 
*          Other 根据调用的子函数返回其它OS_ERR_xxx 
* 返 回 值: 无 
*********************************************************************************************************** 
*/

      3、OSSafetyCriticalStart说明：
/* 
*********************************************************************************************************** 
*                                               创建对象已经不安全
*
* 函数说明: 这个函数是供用户调用的，用户一旦调用了这个函数就表示所有的初始化已经完成。内核对象不再运行被创建。
*           调用此函数后不能再创建任务。(是IEC61508《电气/电子/可编程电子安全相关系统的功能安全》要求，可以提
*           高系统稳定性)。
* 形    参: 无 
* 返 回 值: 无 
* 注    意: 无 
*********************************************************************************************************** 
*/

      4、OSIntEnter说明：
/* 
*********************************************************************************************************** 
*                                          进入中断服务程序 
* 功能说明: 此函数用通知uC/OS-III系统程序将要执行interrupt service routine(ISR)。这样uC/OS-III就可以不断 
*           跟踪中断嵌套次数的变化，这样就能够保证系统只有在最后一层中断执行任务调度。 
* 形    参: 无 
* 返 回 值: 无 
* 注    意: 1) 此函数必须在中断关闭情况下调用。 
*           2) 用户可以不调用这个函数，直接调用全局变量OSIntNestingCtr进行操作即可。 
*           3) 用户必须调用函数OSIntExit()，即使直接的操作'OSIntNestingCtr'。 
*           4) 用户必须成对的调用OSIntEnter() 和 OSIntExit()。换句话说，用户必须在中断服务程序开始和结尾的 
*              时候成对调用OSIntEnter() 和 OSIntExit()。 
*           5) uC/OS-III系统的中断嵌套层数最高250。 
*********************************************************************************************************** 
*/

      5、OSIntExit说明：
/* 
*********************************************************************************************************** 
*                                          退出中断服务程序 
* 
* 函数说明: 此函数用于通知uC/OS-III系统已经完成中断服务程序，然后调用调度器决定是否切换还到新的高优先级任务 
* 形    参: 无 
* 返 回 值: 无 
* 注    意: 1) 用户必须成对的调用OSIntEnter() 和 OSIntExit()。 
*           2) 使用调度锁的话，调度功能将被关闭 (见 OSSchedLock()) 
*********************************************************************************************************** 
*/

      6、OSSchedLock说明：
/* 
*********************************************************************************************************** 
*                                            调度器加锁 
* 
* 函数功能: 此函数的主要作用是给系统调度器加锁，这样系统就无法进行任务调度了。 
*           给调度器加锁后将禁止任务调度，直到任务完成后，调用调度器解锁函数才能重新开始任务调度。
*           这里一定要明白一点，调度锁只是将调度器关闭，并不影响中断的执行，该进中断还是要进的，
*           只是不会执行任务切换。
* 形    参: p_err 错误代码指针变量: 
*                                  OS_ERR_NONE 调度器被锁 
*                                  OS_ERR_LOCK_NESTING_OVF 调度锁嵌套次数 > 250 
*                                  OS_ERR_OS_NOT_RUNNING 如果uC/OS-III还没有开始运行 
*                                  OS_ERR_SCHED_LOCK_ISR 如果在中断服务程序中调用此函数 
* 返 回 值: 无 
* 注    意: 1) OSSchedLock() 和 OSSchedUnlock() 必须成对的使用. 
*********************************************************************************************************** 
*/

      7、OSSchedUnlock说明：
/* 
*********************************************************************************************************** 
*                                             调度器解锁 
* 
* 函数功能: 此函数的主要作用是给系统调度器解锁，重新使能调度 
* 形    参: p_err 错误代码指针变量: 
*                                  OS_ERR_NONE 
*                                  OS_ERR_OS_NOT_RUNNING 系统还没有开始运行 
*                                  OS_ERR_SCHED_LOCKED 调度器仍然是加锁状态 
*                                  OS_ERR_SCHED_NOT_LOCKED 调度没有被加锁 
*                                  OS_ERR_SCHED_UNLOCK_ISR 如果在中断服务程序中调用此函数
* 返 回 值: 无 
* 注    意: 1) OSSchedLock() 和 OSSchedUnlock() 必须成对的使用. 
*********************************************************************************************************** 
*/

      8、OSSchedRoundRobinCfg说明：
/* 
*********************************************************************************************************** 
*                                   配置ROUND-ROBIN调度参数 
* 
* 函数功能: 调用此函数用更改ROUND-ROBIN调度的参数。 
* 形    参: en                 DEF_EN：使能ROUND-ROBIN 
*                              DEF_DIS：禁止ROUND-ROBIN 
*           dflt_time_quanta   默认的时间片数，如果是0 那么就表示时间片是默认的OSCfg_TickRate_Hz / 10. 
*           p_err              错误代码指针变量 
*                              OS_ERR_NONE 调用成功 
* 返 回 值: 无 
*********************************************************************************************************** 
*/

      9、OSSchedRoundRobinYield说明：
/* 
*********************************************************************************************************** 
*                          当任务不再需要剩余时间片时放弃CPU使用权 
* 
* 功能说明: 当任务的时间片还没用完的时候，可以通过此函数放弃剩余时间片，也就是放弃CPU使用权。 
* 形    参: p_err              错误代码指针变量 
*                              OS_ERR_NONE 函数调用成功 
*                              OS_ERR_ROUND_ROBIN_1 此优先级下只有这一个任务，能够放弃CPU权 
*                              OS_ERR_ROUND_ROBIN_DISABLED Round Robin调度没有使能 
*                              OS_ERR_SCHED_LOCKED 调度器被锁 
*                              OS_ERR_YIELD_ISR 不能在中断服务程序中调用此函数 
* 返 回 值: 无 
* 注    意: 1) 此函数必须在任务中调用 
*********************************************************************************************************** 
*/

      10、使用举例：
/* 
********************************************************************************************************* 
* 函数名: main 
* 功能说明: 标准c程序入口。 
* 形 参：无 
* 返回值: 无 
********************************************************************************************************* 
*/ 
int main(void) 
{ 
	OS_ERR err; 
	OSInit(&err); 
	
	/* 使能并设置全局时间片个数 */ 
	OSSchedRoundRobinCfg(DEF_ENABLED, 8, &err); 
	
	OSTaskCreate((OS_TCB *)&AppTaskStartTCB, 
				 (CPU_CHAR *)"App Task Start", 
				 (OS_TASK_PTR )AppTaskStart, 
				 (void *)0, 
				 (OS_PRIO )APP_CFG_TASK_START_PRIO, 
				 (CPU_STK *)&AppTaskStartStk[0], 
				 (CPU_STK_SIZE )APP_CFG_TASK_START_STK_SIZE / 10, 
				 (CPU_STK_SIZE )APP_CFG_TASK_START_STK_SIZE, 
				 (OS_MSG_QTY )0, 
				 (OS_TICK )0, 
				 (void *)0,
				 (OS_OPT )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR), 
				 (OS_ERR *)&err); 
	
	OSStart(&err);
	
	return (0); 
}
/* 
********************************************************************************************************* 
* 函 数 名: AppTaskCom 
* 功能说明: 此任务未使用 
* 形    参：p_arg 是在创建该任务时传递的形参 
* 返 回 值: 无 
********************************************************************************************************* 
*/ 
static void AppTaskCOM(void *p_arg) 
{ 
	OS_ERR err; 
	(void)p_arg; 
	while(1) 
	{ 
		…… 
		OSSchedRoundRobinYield (&err); 
		…… 
	} 
}

      11、中断函数模板：
/* 
********************************************************************************************************* 
* 函 数 名: SDIO_IRQHandler 
* 功能说明: SDIO中断服务程序 
* 形 参：无 
* 返 回 值: 无 
********************************************************************************************************* 
*/ 
void SDIO_IRQHandler(void) 
{ 
	CPU_SR_ALLOC();// 申请cpu_sr
	
	OSIntEnter(); // 进入中断，中断层数加一
	CPU_CRITICAL_ENTER(); // 关键端，关闭全局中断，视具体情况添加此语句
	
	SD_ProcessIRQSrc();// 中断函数
	
	CPU_CRITICAL_EXIT(); // 退出关键端，开启全局中断，视具体情况添加此语句
	OSIntExit(); // 中断层数减一，并进行中断级任务切换
}
